<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-04-04T16:21:44-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hashim Colombowala</title><subtitle>Learning to make cloud tools with python. Hoping to write short technical blogs.</subtitle><entry><title type="html">Python decorator common use cases</title><link href="http://localhost:4000/python/decorator/2020/04/04/python-decorator-use-cases.html" rel="alternate" type="text/html" title="Python decorator common use cases" /><published>2020-04-04T15:54:35-07:00</published><updated>2020-04-04T15:54:35-07:00</updated><id>http://localhost:4000/python/decorator/2020/04/04/python-decorator-use-cases</id><content type="html" xml:base="http://localhost:4000/python/decorator/2020/04/04/python-decorator-use-cases.html">&lt;ul&gt;
  &lt;li&gt;Timing functions. Almost always the first example on StackOverflow. (You can always use a Context Manager for these too, writing them is a good way to learn those and their &lt;code class=&quot;highlighter-rouge&quot;&gt;__enter__&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;__exit__&lt;/code&gt; dunders.)&lt;/li&gt;
  &lt;li&gt;Retrying functions. Bonus points for having longer times between tries per try.&lt;/li&gt;
  &lt;li&gt;Setting a maximum time for a function to finish executing, if the function is amenable to it (e.g. it runs in a loop)&lt;/li&gt;
  &lt;li&gt;Logging functions. There are tons of different types of these (and some PyPI packages that are based on this), because there are tons of different use cases for logging. They generally require a decorator factory or class, because they require parameters (such as the logger instance).&lt;/li&gt;
  &lt;li&gt;Simple debugging, sending a function’s inputs and outputs to a log or just stdout
Validating function inputs. Python is EAFP rather than LBYL, but it’s still useful to validate inputs sometimes depending on use case. I’ve written classes that use the same decorator with a bunch of different methods. It’s also handy to CHANGE inputs if they’re in the wrong format, e.g. if the user forgets to start a url with &lt;code class=&quot;highlighter-rouge&quot;&gt;http://&lt;/code&gt;, you can add it.&lt;/li&gt;
  &lt;li&gt;Validating function outputs, for example setting a max/min.&lt;/li&gt;
  &lt;li&gt;Waiting/rate-limiting. Don’t want that web service to ban you for pinging them too frequently!&lt;/li&gt;
  &lt;li&gt;Caching/memoization. If you’ve got an pure/idempotent (i.e. a functional programming pagradigm functions) that’s also expensive (big O/long running time) that you run several times, sometimes with the same inputs, why not cache the results so you don’t have to recalculate from scratch? Eg: &lt;code class=&quot;highlighter-rouge&quot;&gt;functools.lru_cache&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Gracefully handling database transactions, e.g. rolling back if there’s an Exception (although many DB-API packages come with their own ways to set this up)&lt;/li&gt;
  &lt;li&gt;Synchronization, i.e. acquiring and releasing locks in multithreading/multiprocessing applications&lt;/li&gt;
  &lt;li&gt;Authentication (this is what some web framework decorators do, i.e. make sure a user is logged in before they are allowed to do some task/access some resource)&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Timing functions. Almost always the first example on StackOverflow. (You can always use a Context Manager for these too, writing them is a good way to learn those and their __enter__ and __exit__ dunders.) Retrying functions. Bonus points for having longer times between tries per try. Setting a maximum time for a function to finish executing, if the function is amenable to it (e.g. it runs in a loop) Logging functions. There are tons of different types of these (and some PyPI packages that are based on this), because there are tons of different use cases for logging. They generally require a decorator factory or class, because they require parameters (such as the logger instance). Simple debugging, sending a function’s inputs and outputs to a log or just stdout Validating function inputs. Python is EAFP rather than LBYL, but it’s still useful to validate inputs sometimes depending on use case. I’ve written classes that use the same decorator with a bunch of different methods. It’s also handy to CHANGE inputs if they’re in the wrong format, e.g. if the user forgets to start a url with http://, you can add it. Validating function outputs, for example setting a max/min. Waiting/rate-limiting. Don’t want that web service to ban you for pinging them too frequently! Caching/memoization. If you’ve got an pure/idempotent (i.e. a functional programming pagradigm functions) that’s also expensive (big O/long running time) that you run several times, sometimes with the same inputs, why not cache the results so you don’t have to recalculate from scratch? Eg: functools.lru_cache. Gracefully handling database transactions, e.g. rolling back if there’s an Exception (although many DB-API packages come with their own ways to set this up) Synchronization, i.e. acquiring and releasing locks in multithreading/multiprocessing applications Authentication (this is what some web framework decorators do, i.e. make sure a user is logged in before they are allowed to do some task/access some resource)</summary></entry></feed>