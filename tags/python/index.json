[{"content":"When deploying a containerized application to a container management system like AWS Fargate, you tend to run your application from a shell script. Suppose your script looks like this\n1 2 3  set -o nounset set -x gunicorn --config config/gunicorn/$GUNICORN_CONFIG.py config.wsgi   Here we are executing the gunicorn service with PID 1 when the container is deployed. Suppose we want to terminate the container with a docker stop \u0026lt;container_id\u0026gt;, the command will send a SIGTERM to the container. As the gunicorn process is PID 1, this signal is ignored.\nThe way to resolve this issue is to use exec before the command to start your application. The last line of the above shell script should be gunicorn --config config/gunicorn/$GUNICORN_CONFIG.py config.wsgi. A simple example is shown below\nt.py:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import signal import time got_signal = False def process_signal(signum, frame): global got_signal got_signal = True signal.signal(signal.SIGINT, process_signal) signal.signal(signal.SIGTERM, process_signal) while not got_signal: time.sleep(1) print(\u0026#34;looping...\u0026#34;) print(\u0026#34;Ended with signal.\u0026#34;)   entry.sh:\n1 2  #!/usr/bin/env bash exec python ./t.py   Dockerfile:\n1 2 3 4 5  FROMpython:3.7WORKDIR/usr/src/appCOPY . .CMD [ \u0026#34;./entry.sh\u0026#34; ]  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  With the exec: $ docker run --rm -t signal looping... looping... looping... looping... looping... looping... Ended with signal. $ Without the exec: $ docker run --rm -t signal looping... looping... looping... looping... looping... looping... $   Both times, you can run docker stop in another window. If the container doesn’t stop within 10 seconds, then it’s killed.\nMost apps do not explicitely handle SIGTERM the way t.py does. If you replace t.py with\n1 2 3 4 5 6 7  import time while True: time.sleep(1) print(\u0026#34;looping...\u0026#34;) print(\u0026#34;Ended with signal.\u0026#34;)   SIGINT will work with keyboard interrupt but docker stop does not because of PID=1 issue.\nIf we run docker with a --init option to force a non 1 PID, the docker stop works whether we use exec in the script or not.\nIn order to use this feature with AWS Fargate, make a small change to your AWS::ECS::TaskDefinition in your cloudformation as shown below\n1 2 3 4 5 6  ContainerDefinitions:- Name:\u0026lt;container_name\u0026gt;Image:\u0026lt;container_image\u0026gt;Essential:\u0026#34;true\u0026#34;linuxParameters:initProcessEnabled:\u0026#34;true\u0026#34;  ","description":"","id":0,"section":"posts","tags":["python","docker"],"title":"Signalling docker containers","uri":"https://hashimcolombowala.com/posts/signal/"},{"content":"In python3 all classes are new style classes, thus it is reasonable to refer to an objects type and its class interchangably\nType and Class 1 2 3 4 5 6 7  class Foo: pass \u0026gt;\u0026gt;\u0026gt; type(Foo) \u0026lt;class \u0026#39;type\u0026#39;\u0026gt;   Type is a metaclass of which classes are instances\n Foo is an instance of metaclass type type is an instance of type as well  Type Metaclass A type metaclass is initialized with 3 arguments\n name: name of the class (name attribute) bases: a tuple of classnames that the class inherits from namespace: a dictionary contianing definitions of the class body (dict attribute of the class)  Creating an abstract class manually with Metaclasses To understand metaclasses, we create an interface or abstract class implementation. Use from abc import ABC, abstractmethod when implementing something at work.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  # test.py # Decorator to add attribute to function def abstract_func(func): func.__isabstract__ = True return func # This is the metaclass inheriting from `type` class Interface(type): def __init__(self, name, bases, namespace): print(f\u0026#34;Init method initialized from {self}\u0026#34;) class_methods = getattr(self, \u0026#39;all_methods\u0026#39;) for base in bases: required_methods = getattr(base, \u0026#39;abstract_methods\u0026#39;) for method in required_methods: if method not in class_methods: msg = f\u0026#34;\u0026#34;\u0026#34;Can\u0026#39;t create abstract class {name}! {name}must implement abstract method {method}of class {base}!\u0026#34;\u0026#34;\u0026#34; raise TypeError(msg) def __new__(cls, name, bases, namespace): namespace[\u0026#39;abstract_methods\u0026#39;] = Interface._get_abstract_methods(namespace) namespace[\u0026#39;all_methods\u0026#39;] = Interface._get_all_methods(namespace) cls = super().__new__(cls, name, bases, namespace) return cls def _get_abstract_methods(namespace): ret = [] for name, val in namespace.items(): if callable(val) and getattr(val, \u0026#39;__isabstract__\u0026#39;, False): ret.append(name) return ret def _get_all_methods(namespace): ret = [] for name, val in namespace.items(): if callable(val): ret.append(name) return ret # the __calls__() function calls the __new__() and __init__() methods of the metaclass class NetworkInterface(metaclass=Interface): @abstract_func def connect(self): pass @abstract_func def transfer(self): pass # The object of this class will not be created  # because of missing abstract method class TestNetwork(NetworkInterface): def __init__(self): print(f\u0026#34;Init method initialized from {self}\u0026#34;) def connect(self): pass # def transfer(self): # pass c = TestNetwork() \u0026gt;\u0026gt;\u0026gt; TypeError: Can\u0026#39;t create abstract class TestNetwork! TestNetwork must implement abstract method transfer of class \u0026lt;class \u0026#39;__main__.NetworkInterface\u0026#39;\u0026gt;! After uncommenting the method \u0026gt;\u0026gt;\u0026gt; python3 test.py Init method initialized from \u0026lt;class \u0026#39;__main__.NetworkInterface\u0026#39;\u0026gt; Init method initialized from \u0026lt;class \u0026#39;__main__.TestNetwork\u0026#39;\u0026gt; Init method called from \u0026lt;__main__.TestNetwork object at 0x7fc5e7659350\u0026gt;   When we initialize TestNetwork, the following happens\n The interface init method is called twice. Once when creating the NetworkInterface and TestNetwork class from the metaclass blueprint. In the Interface init method, we iterate over the list of abstract methods in the parent class and make sure each one is present in the current class. If we don\u0026rsquo;t find a method in the class with the same name, we raise an exception  ","description":"","id":1,"section":"posts","tags":["python"],"title":"Abstract classes using Metaclasses","uri":"https://hashimcolombowala.com/posts/2020-12-28-python-metaclasses/"},{"content":"The Go compiler can compile the Go source go with different go specs. Fo example, if you have installed go 1.14, you can compile your source with Go spec 1.13.\nThe rules for which version of the Go spec used during compilation appear to be  If your source code is stored within the GOPATH (or you have disabled modules with GO111MODULE=off) then the version of the Go spec used to compile matches the version of the compiler you are using. ie if you have go 1.13(GOROOT points to your go installation) installed then the go spec used will be 1.13 If your source code is outside the GOPATH(or GO111MODULE=on), then the go tool will take the version from the go.mod file If no go.mod file is provided, then same as point 1 If you are in module mode(see point 2) and no version is specified in the go.mod file, then go 1.13 is used by default  The last point is interesting.\nReference: https://www.jetbrains.com/help/go/configuring-goroot-and-gopath.html\n","description":"","id":2,"section":"posts","tags":["go"],"title":"The Go Spec(compiling)","uri":"https://hashimcolombowala.com/posts/2020-06-20-the-go-spec/"},{"content":"Words of wisdom from the python interactive shell. Always good to read it once in a while and appreciate the zen of python.\nOpen the python interpretor and enter import this\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026gt;\u0026gt;\u0026gt; import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren\\\u0026#39;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you\\\u0026#39;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it\\\u0026#39;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let\\\u0026#39;s do more of those!   ","description":"","id":3,"section":"posts","tags":null,"title":"The Zen of Python","uri":"https://hashimcolombowala.com/posts/2020-04-17-zen-of-python/"},{"content":"A polyglot and pragrammatic programmer with an M.S. in Electrical Engineering. I have a background in systems engineering and love building tools for automation.\nOutside of tech, I love playing football (soccer), cricket and ping pong. I am an avid Liverpool football club fan and often wake up early in the morning to watch them play.\n","description":"","id":4,"section":"","tags":null,"title":"About","uri":"https://hashimcolombowala.com/about/"}]