<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Python decorator common use cases | Hashim Colombowala</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Python decorator common use cases" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Timing functions. Almost always the first example on StackOverflow. (You can always use a Context Manager for these too, writing them is a good way to learn those and their __enter__ and __exit__ dunders.) Retrying functions. Bonus points for having longer times between tries per try. Setting a maximum time for a function to finish executing, if the function is amenable to it (e.g. it runs in a loop) Logging functions. There are tons of different types of these (and some PyPI packages that are based on this), because there are tons of different use cases for logging. They generally require a decorator factory or class, because they require parameters (such as the logger instance). Simple debugging, sending a function’s inputs and outputs to a log or just stdout Validating function inputs. Python is EAFP rather than LBYL, but it’s still useful to validate inputs sometimes depending on use case. I’ve written classes that use the same decorator with a bunch of different methods. It’s also handy to CHANGE inputs if they’re in the wrong format, e.g. if the user forgets to start a url with http://, you can add it. Validating function outputs, for example setting a max/min. Waiting/rate-limiting. Don’t want that web service to ban you for pinging them too frequently! Caching/memoization. If you’ve got an pure/idempotent (i.e. a functional programming pagradigm functions) that’s also expensive (big O/long running time) that you run several times, sometimes with the same inputs, why not cache the results so you don’t have to recalculate from scratch? Eg: functools.lru_cache. Gracefully handling database transactions, e.g. rolling back if there’s an Exception (although many DB-API packages come with their own ways to set this up) Synchronization, i.e. acquiring and releasing locks in multithreading/multiprocessing applications Authentication (this is what some web framework decorators do, i.e. make sure a user is logged in before they are allowed to do some task/access some resource)" />
<meta property="og:description" content="Timing functions. Almost always the first example on StackOverflow. (You can always use a Context Manager for these too, writing them is a good way to learn those and their __enter__ and __exit__ dunders.) Retrying functions. Bonus points for having longer times between tries per try. Setting a maximum time for a function to finish executing, if the function is amenable to it (e.g. it runs in a loop) Logging functions. There are tons of different types of these (and some PyPI packages that are based on this), because there are tons of different use cases for logging. They generally require a decorator factory or class, because they require parameters (such as the logger instance). Simple debugging, sending a function’s inputs and outputs to a log or just stdout Validating function inputs. Python is EAFP rather than LBYL, but it’s still useful to validate inputs sometimes depending on use case. I’ve written classes that use the same decorator with a bunch of different methods. It’s also handy to CHANGE inputs if they’re in the wrong format, e.g. if the user forgets to start a url with http://, you can add it. Validating function outputs, for example setting a max/min. Waiting/rate-limiting. Don’t want that web service to ban you for pinging them too frequently! Caching/memoization. If you’ve got an pure/idempotent (i.e. a functional programming pagradigm functions) that’s also expensive (big O/long running time) that you run several times, sometimes with the same inputs, why not cache the results so you don’t have to recalculate from scratch? Eg: functools.lru_cache. Gracefully handling database transactions, e.g. rolling back if there’s an Exception (although many DB-API packages come with their own ways to set this up) Synchronization, i.e. acquiring and releasing locks in multithreading/multiprocessing applications Authentication (this is what some web framework decorators do, i.e. make sure a user is logged in before they are allowed to do some task/access some resource)" />
<link rel="canonical" href="http://localhost:4000/python/decorator/2020/04/04/python-decorator-use-cases.html" />
<meta property="og:url" content="http://localhost:4000/python/decorator/2020/04/04/python-decorator-use-cases.html" />
<meta property="og:site_name" content="Hashim Colombowala" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-04T15:54:35-07:00" />
<script type="application/ld+json">
{"headline":"Python decorator common use cases","dateModified":"2020-04-04T15:54:35-07:00","datePublished":"2020-04-04T15:54:35-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/python/decorator/2020/04/04/python-decorator-use-cases.html"},"description":"Timing functions. Almost always the first example on StackOverflow. (You can always use a Context Manager for these too, writing them is a good way to learn those and their __enter__ and __exit__ dunders.) Retrying functions. Bonus points for having longer times between tries per try. Setting a maximum time for a function to finish executing, if the function is amenable to it (e.g. it runs in a loop) Logging functions. There are tons of different types of these (and some PyPI packages that are based on this), because there are tons of different use cases for logging. They generally require a decorator factory or class, because they require parameters (such as the logger instance). Simple debugging, sending a function’s inputs and outputs to a log or just stdout Validating function inputs. Python is EAFP rather than LBYL, but it’s still useful to validate inputs sometimes depending on use case. I’ve written classes that use the same decorator with a bunch of different methods. It’s also handy to CHANGE inputs if they’re in the wrong format, e.g. if the user forgets to start a url with http://, you can add it. Validating function outputs, for example setting a max/min. Waiting/rate-limiting. Don’t want that web service to ban you for pinging them too frequently! Caching/memoization. If you’ve got an pure/idempotent (i.e. a functional programming pagradigm functions) that’s also expensive (big O/long running time) that you run several times, sometimes with the same inputs, why not cache the results so you don’t have to recalculate from scratch? Eg: functools.lru_cache. Gracefully handling database transactions, e.g. rolling back if there’s an Exception (although many DB-API packages come with their own ways to set this up) Synchronization, i.e. acquiring and releasing locks in multithreading/multiprocessing applications Authentication (this is what some web framework decorators do, i.e. make sure a user is logged in before they are allowed to do some task/access some resource)","@type":"BlogPosting","url":"http://localhost:4000/python/decorator/2020/04/04/python-decorator-use-cases.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Hashim Colombowala" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Hashim Colombowala</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Python decorator common use cases</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-04-04T15:54:35-07:00" itemprop="datePublished">Apr 4, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul>
  <li>Timing functions. Almost always the first example on StackOverflow. (You can always use a Context Manager for these too, writing them is a good way to learn those and their <code class="highlighter-rouge">__enter__</code> and <code class="highlighter-rouge">__exit__</code> dunders.)</li>
  <li>Retrying functions. Bonus points for having longer times between tries per try.</li>
  <li>Setting a maximum time for a function to finish executing, if the function is amenable to it (e.g. it runs in a loop)</li>
  <li>Logging functions. There are tons of different types of these (and some PyPI packages that are based on this), because there are tons of different use cases for logging. They generally require a decorator factory or class, because they require parameters (such as the logger instance).</li>
  <li>Simple debugging, sending a function’s inputs and outputs to a log or just stdout
Validating function inputs. Python is EAFP rather than LBYL, but it’s still useful to validate inputs sometimes depending on use case. I’ve written classes that use the same decorator with a bunch of different methods. It’s also handy to CHANGE inputs if they’re in the wrong format, e.g. if the user forgets to start a url with <code class="highlighter-rouge">http://</code>, you can add it.</li>
  <li>Validating function outputs, for example setting a max/min.</li>
  <li>Waiting/rate-limiting. Don’t want that web service to ban you for pinging them too frequently!</li>
  <li>Caching/memoization. If you’ve got an pure/idempotent (i.e. a functional programming pagradigm functions) that’s also expensive (big O/long running time) that you run several times, sometimes with the same inputs, why not cache the results so you don’t have to recalculate from scratch? Eg: <code class="highlighter-rouge">functools.lru_cache</code>.</li>
  <li>Gracefully handling database transactions, e.g. rolling back if there’s an Exception (although many DB-API packages come with their own ways to set this up)</li>
  <li>Synchronization, i.e. acquiring and releasing locks in multithreading/multiprocessing applications</li>
  <li>Authentication (this is what some web framework decorators do, i.e. make sure a user is logged in before they are allowed to do some task/access some resource)</li>
</ul>

  </div><a class="u-url" href="/python/decorator/2020/04/04/python-decorator-use-cases.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Hashim Colombowala</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Hashim Colombowala</li><li><a class="u-email" href="mailto:hash167@gmail.com">hash167@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/hash167"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">hash167</span></a></li><li><a href="https://www.twitter.com/unusuallastname"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">unusuallastname</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Learning to make cloud tools with python.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
